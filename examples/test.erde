-- -----------------------------------------------------------------------------
-- Punctuation
-- -----------------------------------------------------------------------------

!a
#a
~a
a | b
a & b
a ~ b
a + b
a - b
a < b
a > b
a = b
a + b
a - b
a * b
a / b
a % b
a ^ b
a .. b
a == b
a != b
a <= b
a >= b
a || b
a && b
a << b
a >> b
a += b
a ~= b

a.b[c]()

-- Anti-Examples

())
[]]
{}}

-- -----------------------------------------------------------------------------
-- Comments
-- -----------------------------------------------------------------------------

-- this is an inline comment

--[[
this is a block comment
]]

-- NOTE
-- TODO
-- FIXME
-- XXX
-- TBD

#! this is a shebang

-- -----------------------------------------------------------------------------
-- Std Library
-- -----------------------------------------------------------------------------

local x = require('test')
_VERSION

coroutine.create()
coroutine.createee()

-- Anti-Examples

x = tables
a.assert()
acoroutine.create()
a.coroutine.create()

-- -----------------------------------------------------------------------------
-- Types (Primitives)
-- -----------------------------------------------------------------------------

nil

true
false

43
0x3fa
0x9.aaeep+3
.543
30.43
30e3
30e+3
30e-3

'single {word} string'
'single {99} string'
"Breakdouble {99} string"

[[ long {99} ]]
[=[ long {0x43} ]=]
[[
{99}a]]

'single \n string'
'single \x12 string'
'single \x12 string'
'single \1 string'
'single \u{12d1} string'
'single \
string'

self

-- Anti-Examples

-- (no escape highlighting)
'single \x1 string'
'single \{99\} string'
'single \{99} string'
"single \{99\} string"
"single \{99} string"
"single \ 
string"

-- -----------------------------------------------------------------------------
-- Types (Table)
-- -----------------------------------------------------------------------------

local x = { z = { x } }
local x = {
  mykey = { x = 2 },
  ['mykey'] = (a, b) => { return a + b },
  mykey = a -> ({ 1, 2 }),
  mykey = 3,
  print = '',
  mykey = print,
}

x.test
({ a = 2 }).a

-- Anti-Examples

x.local
x.return
x.catch()

-- -----------------------------------------------------------------------------
-- Types (Functions)
-- -----------------------------------------------------------------------------

local function test() {}
global function test() {}
module function test() {}

function test(a, b = 3, ...c) {}
function test(a = {}) {}
local function test.test:test() {}

local x = () -> "test"
local x = () -> { return }
local x = (a, b) => (1, 2, "hi")
myfunc(() -> print('hello world'))

test.test()
test(1, 2, 3, a, b, c)
test.test(1, 2, 3, a, b, c)
test.test:test(1, 2, 3, a, b, c)
test.test[1]:test(1, 2, 3, a, b, c)

type(() -> {})

return {}

return (
  1,
  2,
  3,
)

-- -----------------------------------------------------------------------------
-- Destructuring
-- -----------------------------------------------------------------------------

local a, { a = 2, b } = 1, 4

local [ hello, world ] = myfunc()

local { print } = myfunc()

local { print = {} } = myfunc()

local { print: test = 1 } = myfunc()

local {
  a,
  b
}, b = 4

local function test({ test }) {}
global function test({ print }) {}
local function test([ test ]) {}
global function test([ print ]) {}

local x = { test } -> { return }
local x = { print } -> { return }
local x = [ test ] -> { return }
local x = [ print ] -> { return }

for { test } in myiter() { }
for { print } in myiter() { }
for [ test ] in myiter() { }
for [ print ] in myiter() { }
for i, { test } in myiter() { }
for { test }, i in myiter() { }

try {} catch { test } {}
try {} catch { print } {}
try {} catch [ test ] {}
try {} catch [ print ] {}

-- -----------------------------------------------------------------------------
-- Blocks / Statements
-- -----------------------------------------------------------------------------

local a, b
local a = 4
global b = 4
module c = 4
local a, b, c = 1, 2, 3
local MY_CONSTANT = 4

do { }

if {} + {} {}
if a.b[c]() {}
if test({1, 2}) { }
elseif 1 { }
else { }

repeat { } until 3
while x {}

for i = 1, 2 { }
for k, v in ipairs() { hello }
for k, v in ipairs() { a.b = instance }

return

while true {
  break
  continue
}

try {}
catch {
}

goto test
::test::

if x {
}
